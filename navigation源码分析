https://github.com/ros-planning/navigation
astar.cpp:
toIndex：将地图上的二维地图转化为一维序列，比如坐标（1，3）对于5*5的方格地图序号就是1+3*5=16
potential：势能A*算法的gn，用来表示初始点到该店的代价的估计
Cycle：循环次数
queue_:优先级队列（最小堆）
neutral_cost_：本源代价，就是每走一步的单位代价
A*算法：所有的搜索算法本质是维护一个open表，A*算法维护一个优先级队列，优先级队列的优先级是gn+hn，gn是初始节点到该节点的代价估计，hn是从该节点到目标节点代价的估计，gn可以从已知事实出发估计，而hn只能用启发式的方法估计，A*算法维护open表在于，每次出队一个元素如果是目标节点则退出，否则重新整理open表，然后考察所有出队的点的邻近点也就是搜索树中的儿子节点，将他们按照优先级入队，如此反复，直到找到目标节点或者open表为空无法维护失败退出。
dijkstra.cpp:
Dijkstra算法:计算源节点到目的点的最短路径，要求是路径权值非负且为连通图，基本思想是维护v和s两个集合和一条最短路径和记录源节点到每个点的路径代价数组，初始将源节点放入s集合，其余点放入v集合，数组初始代价为，和源节点直接相连的点代价为直接代价，其余代价为正无穷，按照代价数组从v中选出一个代价最小的节点放入s集合中，然后更新代价数组，如此反复直到所有节点都加入了s集合中。
本cpp的算法结合了dijstra算法和宽度优先搜索算法，dijstra算法时间复杂度是O(N^2),但是如果只用dijstra，会导致空间开销过大所以结合宽度优先搜索，设置了三个缓冲区进行批处理，每个缓冲区的实质是一个队列。算法开始设定初始点，然后把初始点的临近点放进current队列，这里算法还设置了是否精确计算，不过都是将临近点入队，然后开始了循环处理，首先重新计算current队列里的势值，保证从源节点到这个节点的势值最小，并将其中的所有邻接点放入剩下的两个队列，如果此节点的势小于阈值就把邻接点放入高优先级的队列next，否则把邻接点放入低优先级的队列over，处理完current队列，然后处理next队列，如果next为空那么处理over队列，并提高阈值。
gradient.cpp：
类似于梯度下降的原理，不同于上两种算法，是从目的节点导出到源节点的路径序列，循环初始把一维序列号转化为二维坐标值，然后把这个二维坐标值放入path中，如果这个二维坐标值邻近源节点那么放到path中并且成功返回，否则继续循环计算下一个一维序列号。首先检查是否有震荡情况出现，然后检查当前二维坐标的8个方向上是否有障碍物或者已出现震荡情况，如果是那么需要移动到最小势的那个位置，如果周围所有势能都高于阈值那么失败返回。如果8个方向没有障碍物且没有震荡情况，那么这个位置会有较好的梯度，可以按照梯度行进，行进的时候要注意处理偏移值过大的情况。
grid_path.cpp：
简化版的gradient.cpp不考虑梯度只按照网格线的8个方向移动，每次移动会使势能值下降最大
orientation_filter.cpp:
主要是行进时候角度的问题，代码分为了三种模式来计算行进过程中的角度第一种FORWARD模式，根据路径上相邻的两个点计算角度偏移，INTERPOLATE模式，计算初始位置和最终位置的相对角度，均分得到角度偏移，FORWARDTHENINTERPOLATE模式，先按照forwoard模式计算角度偏移，找到其中的一部分，使其起始终止的相对偏移大于某个设定值的时候，角度偏移值改为均分值。
planner_core.cpp:
核心在于用dijkstra或者A*算法计算好地图上相关点的势，然后再利用gradient或者grid_path利用计算好的势得到源点到目标点的路径，最后将路径返回给订阅端。
plan_node.cpp：
配置ros节点，配置服务端等
quardratic_calculator.cpp:
计算势的函数，可以根据相关参数调整采用这个来计算势。
